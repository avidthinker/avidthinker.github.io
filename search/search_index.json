{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Web3 Security Blog","text":""},{"location":"tags/","title":"Tags","text":""},{"location":"tags/#tag:ecdsa","title":"ECDSA","text":"<ul> <li>            Understanding ECDSA          </li> </ul>"},{"location":"tags/#tag:attack","title":"attack","text":"<ul> <li>            Understanding ECDSA          </li> </ul>"},{"location":"tags/#tag:cryptography","title":"cryptography","text":"<ul> <li>            Understanding ECDSA          </li> </ul>"},{"location":"tags/#tag:ethereum","title":"ethereum","text":"<ul> <li>            Understanding ECDSA          </li> </ul>"},{"location":"tags/#tag:extended-euclidean-algorithm","title":"extended euclidean algorithm","text":"<ul> <li>            Understanding ECDSA          </li> </ul>"},{"location":"tags/#tag:generating-functions","title":"generating functions","text":"<ul> <li>            Understanding ECDSA          </li> </ul>"},{"location":"tags/#tag:signature-malleability","title":"signature malleability","text":"<ul> <li>            Understanding ECDSA          </li> </ul>"},{"location":"2024/11/26/understanding-ecdsa/","title":"Understanding ECDSA","text":"","tags":["attack","cryptography","ECDSA","ethereum","extended euclidean algorithm","generating functions","signature malleability"]},{"location":"2024/11/26/understanding-ecdsa/#prerequisites-and-audience","title":"Prerequisites and audience","text":"<p>In this article, we'll try to understand how ECDSA (Elliptic Curve Digital Signature Algorithm) works.</p> <p>The version I have in mind is the one used by the Ethereum blockchain. Since my interest lies in security, we'll also explore the signature malleability attack.</p> <p>I expect you to be familiar with Public Key Cryptography and how it can be used to sign messages, at least conceptually.</p> <p>You'll only need to know basic math, so abstract algebra is not a requirement. I'll introduce the bare minimum as we go. My exposition will be deliberately unsophisticated, favoring ease of understanding over conciseness and elegance.</p> <p>The reader I have in mind is someone dissatisfied with the many superficial, hand-wavy explanations of ECDSA often found in articles and books aimed at developers and auditors, but who doesn't have the time or interest to go all the way down the rabbit hole and learn cryptography in a thorough and systematic way.</p> <p>If you, like me, work in a field where you need to have a working knowledge of multiple disciplines, you'll probably appreciate this kind of compromise.</p> <p>Finally, this might also serve as an introduction to the topic before you turn to more serious and academic literature.</p>","tags":["attack","cryptography","ECDSA","ethereum","extended euclidean algorithm","generating functions","signature malleability"]},{"location":"2024/11/26/understanding-ecdsa/#not-your-typical-article","title":"Not your typical article","text":"<p>You can think of this section as a kind of disclaimer.</p> <p>This article is the result of an exercise where I start from a vague understanding of a topic and try to connect all the dots and fill in all the gaps on my own, without relying on any external sources of information. This means no books, no LLMs, and no internet.</p> <p>For the exercise to be effective, it needs to be written with an audience in mind, forcing you to keep track of what you've already explained and what you can expect the reader to know. It also helps you do a better job because you feel more exposed.</p> <p>Have you ever gone back to something you learned in the past and realized you forgot most of it? Your knowledge has become sparse and all you remember are some facts disconnected from each other.</p> <p>Can you restore the original picture on your own?</p> <p>If you succeed, your final understanding will be much deeper than the one you'd have if you relied on external help such as books and notes.</p> <p>With this article, I go a step further and try to connect the dots with knowledge that I never had to begin with. The fact that it's possible is what makes mathematical topics so special.</p> <p>That should explain why I wrote it, but why should you read it?</p> <p>Well, you get to read something:</p> <ul> <li>Unusual, which might pique your curiosity,</li> <li>Non-authoritative, demanding your full attention and critical thinking to spot inconsistencies,</li> <li>Constructive in nature, since most of the formulas and derivations have to be recreated from scratch,</li> <li>Non-standard, which might or might not please you:<ul> <li>facts may be stated or named differently from official literature,</li> </ul> </li> <li>Naive, as I observe and notice some connections for the first time,<ul> <li>possibly making my exposition more engaging but also less polished,</li> </ul> </li> <li>Insightful, since I share some of my intuition and mental models, which is somewhat unusual in more rigorous settings.</li> </ul> <p>Your role is that of an auditor or verifier, constantly trying to find any inconsistencies and non sequiturs in what I produced: I'm the generator and you the discriminator. In a (constructively) adversarial setting, this would be an iterative process.</p> <p>It goes without saying that this article is meant to be read linearly, from the start.</p>","tags":["attack","cryptography","ECDSA","ethereum","extended euclidean algorithm","generating functions","signature malleability"]},{"location":"2024/11/26/understanding-ecdsa/#modular-arithmetic","title":"Modular arithmetic","text":"<p>It's all around us:</p> Mon Tue Wed Thu Fri Sat Sun 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 <p>If we're just interested in the day of the week, then the numbers in the same column are equivalent. What do they have in common? The fact that the difference between any two of them is always a multiple of \\(7\\):</p> <ul> <li>\\(29-8 = 21 = 3\\cdot 7\\)</li> <li>\\(22-15 = 7\\)</li> <li>\\(31-17 = 14 = 2\\cdot 7\\)</li> </ul> <p>Since numbers in the same column are equivalent, we can represent all of them by the smallest one. Let's call it the representative of the column. If we do that, we end up with \\(7\\) numbers:</p> Mon Tue Wed Thu Fri Sat Sun 0 1 2 3 4 5 6 <p>That's not ideal for a calendar, but it makes sense: we just add multiples of \\(7\\) to the starting numbers to recover the missing ones.</p> <p>How do we get the representative from a number? For instance, what's the representative of \\(45\\)? Well, \\(45 = 3 + 7\\cdot 6\\), so the representative is \\(3\\). Indeed, starting from \\(3\\), we add a multiple of \\(7\\) to get \\(45\\).</p> <p>Now what's \\(3\\) with respect to \\(45\\)? It's the remainder of \\(45\\) divided by \\(7\\). We can get that number by using the mod(ulo) operator: \\(45\\ \\mathrm{mod}\\ 7 = 3\\), or <code>45 % 7 == 3</code>, in many programming languages.</p> <p>Beware:</p> <ul> <li>In JS: <code>-45 % 7</code> is \\(-3\\)</li> <li>In Solidity: <code>-45 % 7</code> is \\(-3\\)</li> <li>In Python: <code>-45 % 7</code> is \\(4\\)</li> <li>In Math: \\(-45\\ \\mathrm{mod}\\ 7\\) is \\(4\\)</li> </ul> <p>Both values make sense, since they're separated by \\(7\\) and, thus, in the same column, or equivalence class, i.e. the class of all equivalent elements. But we want the representative, so \\(4\\) is preferred. Observe that \\(-45 = -7\\cdot 7 + 4\\).</p> <p>Basically, any time we're outside the window \\(\\{0, \\ldots, 6\\}\\), we add or subtract \\(7\\) as many times as we need to land in the window.</p> <p>Note that <code>((n % 7) + 7) % 7</code> will give the representative in any language, since:</p> <ul> <li><code>n % 7</code> is in \\(\\{-6, -5, \\ldots, 0, \\ldots, 5, 6\\}\\)</li> <li><code>(n % 7) + 7</code> is in \\(\\{1, \\ldots, 13\\}\\)</li> <li><code>((n % 7) + 7) % 7</code> is in \\(\\{0, \\ldots, 6\\}\\)</li> </ul> <p>Observe that:</p> <ul> <li>adding \\(7\\) doesn't change the equivalence class</li> <li><code>(x % 7) % 7</code> is just <code>x % 7</code>. This property is called idempotency (same power): reapplying the operation doesn't increase the extent of the effect, i.e. it gives the same result.</li> </ul> <p>Instead of writing mod operators everywhere, we can say that we're computing mod \\(p\\):</p> \\[y^2 = x^3 + 7\\ (\\mathrm{mod}\\ p)\\] <p>That's equivalent to</p> \\[y^2\\ \\mathrm{mod}\\ p = (x^3 + 7) \\ \\mathrm{mod}\\ p\\] <p>which is a pain to write.</p> <p>If we're only dealing with addition and multiplication, then we can insert as many \"mod \\(p\\)\" as we want wherever we want, so these two expressions are equivalent:</p> <ul> <li>\\((123456 \\cdot 345678 + 876876234)\\ \\mathrm{mod}\\ p\\)</li> <li>\\([(((123456\\ \\mathrm{mod}\\ p)\\cdot (345678 \\ \\mathrm{mod}\\ p))\\ \\mathrm{mod}\\ p) + (876876234\\ \\mathrm{mod}\\ p)]\\ \\mathrm{mod}\\ p\\)</li> </ul> <p>That's not true for exponentiation:</p> <ul> <li>\\(2^8\\ \\mathrm{mod}\\ 7 = 4\\)</li> <li>\\(2^{8\\ \\mathrm{mod}\\ 7} = 2^1 = 2\\)</li> </ul> <p>ECDSA doesn't rely on exponentiation, so we don't need to talk about it.</p> <p>We still don't know how to divide mod \\(p\\). That is, we don't know how to compute, say, \\(3/4\\) mod \\(p\\), or whether it even exists.</p> <p>What does dividing by \\(4\\) do? It does something that can be reversed by multiplying by \\(4\\). So the two operations cancel out and are equivalent to multiplying by \\(1\\), the neutral element. In other words, we must have</p> \\[a / a = 1\\ (\\mathrm{mod}\\ p)\\] <p>That's usually written as</p> \\[a\\cdot a^{-1} = 1\\ (\\mathrm{mod}\\ p)\\] <p>where \\(a^{-1}\\) is called the multiplicative inverse of \\(a\\).</p> <p>As an aside, the additive inverse, or opposite, is simply \\(-n\\), since \\(n + (-n) = 0\\), where \\(0\\) is the neutral element of addition. Of course, we can compute \\(-n\\ \\mathrm{mod}\\ p\\) to get the representative of \\(-n\\).</p> <p>Let's find \\(x\\) such that \\(4\\cdot x = 1\\ (\\mathrm{mod}\\ 7)\\) by using simple brute force:</p> <ul> <li>\\(4\\cdot 0 = 0\\)</li> <li>\\(4\\cdot 1 = 4\\)</li> <li>\\(4\\cdot 2 = 1\\)</li> <li>\\(4\\cdot 3 = 5\\)</li> <li>\\(4\\cdot 4 = 2\\)</li> <li>\\(4\\cdot 5 = 6\\)</li> <li>\\(4\\cdot 6 = 3\\)</li> </ul> <p>I omitted \"\\(\\left(\\mathrm{mod}\\ 7\\right)\\)\" for convenience. I'll do that often from now on.</p> <p>As we can see, \\(4^{-1} = 2\\). That's because \\(4\\cdot 2 = 8 = 8-7 = 1\\).</p> <p>Let's go back to our \\(3/4\\):</p> \\[3/4 = 3\\cdot 4^{-1} = 3\\cdot 2=6\\] <p>Indeed:</p> \\[6\\cdot 4 = 24 = 3\\] <p>so we get \\(3\\) back.</p> <p>An important fact to know is that a number \\(a\\) is always invertible mod \\(p\\), as long as it's coprime with \\(p\\), i.e. their GCD (greatest common divisor) is \\(1\\).</p> <p>Proof (safely skippable)</p> <p>Let's define \\(r_x = a\\cdot x\\ \\mathrm{mod}\\ p\\). Let \\(r\\) be the sequence \\(r_0, \\ldots, r_{p-1}\\).</p> <p>Again, I'll omit \"mod \\(p\\)\" for notational convenience.</p> <p>If \\(r_x = r_y\\), i.e. \\(a\\cdot x = a\\cdot y\\), then \\(a(x-y) = 0\\), which means that \\(a(x-y)\\) is divisible by \\(p\\). If \\(a\\) and \\(p\\) are coprime, then \\(x-y\\) must be divisible by \\(p\\), so \\(x-y = 0\\), i.e. \\(x=y\\). In other words, \\(x\\neq y\\) implies that \\(r_x \\neq r_y\\).</p> <p>This means that \\(r\\) has \\(p\\) distinct values in \\(\\{0, \\ldots, p-1\\}\\), i.e. \\(r\\) is a permutation of the sequence \\(0, \\ldots, p-1\\). In particular, \\(r\\) contains exactly one \\(1\\), so there's exactly one \\(x\\) such that \\(a\\cdot x = 1\\).</p> <p>End of proof!</p> <p>As an example, let's look again at the brute-forcing we did above to find \\(4^{-1}\\ \\mathrm{mod}\\ 7\\) and note that the results are a permutation of the numbers from \\(0\\) to \\(6\\), so they contain exactly one \\(1\\). That's expected since \\(4\\) and \\(7\\) are coprime.</p> <p>Observe that when \\(p\\) is prime, all numbers from \\(1\\) to \\(p-1\\) are coprime with it, so they're all invertible.</p> <p>Technically, the set of representatives \\(0, \\ldots, p-1\\) is often denoted by \\(\\mathbb{Z}_p\\) or \\(\\mathbb{Z}/p\\mathbb{Z}\\). It's obtained by partitioning the integers into equivalence classes (our calendar columns, but extended to all integers) and representing each class by a representative in \\(\\{0, \\ldots, p-1\\}\\). That's what we did informally.</p>","tags":["attack","cryptography","ECDSA","ethereum","extended euclidean algorithm","generating functions","signature malleability"]},{"location":"2024/11/26/understanding-ecdsa/#extended-euclidean-algorithm","title":"Extended Euclidean algorithm","text":"<p>Tip</p> <p>You can safely skip this section, if you already know or don't care about how the multiplicative inverse can be computed in practice. If you're interested in the method of generating functions you might still want to read the Fibonacci numbers subsection, though.</p> <p>For a fast and practical way to compute the multiplicative inverse, we can use the extended Euclidean algorithm (EEA).</p> <p>The Euclidean algorithm (EA) can be used to efficiently compute \\(\\mathrm{GCD}(a, p)\\), and its extended version returns two integers \\(x\\) and \\(y\\) such that</p> \\[ax + py = \\mathrm{GCD}(a, p)\\] <p>If \\(a\\) and \\(p\\) are coprime, then</p> \\[ ax + py = 1 \\implies ax = 1\\ (\\mathrm{mod}\\ p) \\] <p>This means that \\(x\\) is the multiplicative inverse of \\(a\\) mod \\(p\\).</p> <p>How does the algorithm work? It's very simple.</p> <p>The first observation is that</p> \\[\\mathrm{GCD}(a, b) = \\mathrm{GCD}(a, b-a)\\] <p>and, by symmetry,</p> \\[\\mathrm{GCD}(a, b) = \\mathrm{GCD}(a-b, b)\\] <p>We will prove this later.</p> <p>Since we can subtract repeatedly, we can also use the mod operator:</p> \\[\\mathrm{GCD}(a, b) = \\mathrm{GCD}(a\\ \\mathrm{mod}\\ b, b\\ \\mathrm{mod}\\ a)\\] <p>This way, we can reduce the two arguments very quickly. Note that in a real implementation we only need one <code>mod</code> per step, since one of the two has clearly no effect.</p> <p>Let's use it to compute \\(\\mathrm{GCD}(784, 495)\\):</p> \\[ \\begin{align*} (784&amp;, 495) \\\\ (289&amp;, 495)&amp;\\qquad\\qquad 289 &amp;= 784 - 495 \\\\ (289&amp;, 206)&amp;             206 &amp;= 495 - 289 \\\\  (83&amp;, 206)&amp;             83 &amp;= 289 - 206 \\\\  (83&amp;, 40) &amp;             40 &amp;= 206 - 83\\cdot 2 \\\\   (3&amp;, 40) &amp;             3 &amp;= 83 - 40\\cdot 2 \\\\   (3&amp;, 1)  &amp;             1 &amp;= 40 - 3\\cdot 13 \\end{align*} \\] <p>The second column shows how we got the new values. Since we obtained \\(\\mathrm{GCD}(3, 1)\\), the GCD is \\(1\\), i.e. \\(784\\) and \\(495\\) are coprime.</p> <p>The extended version of the algorithm uses the second column in a simple way. To start, we notice that the equation at the bottom of the second column is already in the right form, i.e.</p> \\[40\\cdot 1 + 3(-13) = 1\\] <p>However, we want the expression with respect to the initial values \\(784\\) and \\(495\\).</p> <p>The solution is easy: we just do substitutions as we go up the second column, starting from the bottom:</p> \\[ \\begin{align*} 1 &amp;= 40 - 3\\cdot 13 \\\\ 1 &amp;= 40 - (83 - 40\\cdot 2)\\cdot 13 \\\\   &amp;= 40\\cdot 27 - 83\\cdot 13 \\\\ 1 &amp;= (206 - 83\\cdot 2)\\cdot 27 - 83\\cdot 13 \\\\   &amp;= 206\\cdot 27 - 83\\cdot 67 \\\\ 1 &amp;= 206\\cdot 27 - (289 - 206)\\cdot 67 \\\\   &amp;= 206\\cdot 94 - 289\\cdot 67 \\\\ 1 &amp;= (495 - 289)\\cdot 94 - 289\\cdot 67 \\\\   &amp;= 495\\cdot 94 - 289\\cdot 161 \\\\ 1 &amp;= 495\\cdot 94 - (784 - 495)\\cdot 161 \\\\   &amp;= 495\\cdot 255 - 784\\cdot 161 \\\\ \\end{align*} \\] <p>Indeed, \\(495\\cdot 255 - 784\\cdot 161 = 1\\).</p> <p>So now we know that \\(495\\cdot 255 = 1\\ (\\mathrm{mod}\\ 784)\\).</p> <p>Now, the only thing missing is to prove that</p> \\[\\mathrm{GCD}(a, b) = \\mathrm{GCD}(a, b-a)\\] <p>Let me write \\(a|b\\) to mean that \\(a\\) divides \\(b\\), i.e. \\(b = ah\\) for some integer \\(h\\).</p> <p>If two numbers divide each other, they must be equal, so we just need to prove that, for any integer \\(k\\),</p> \\[\\mathrm{GCD}(u, v)\\mid \\mathrm{GCD}(u, v+ku)\\] <p>Indeed, we can then argue that:</p> <ul> <li>\\(\\mathrm{GCD}(a, b) \\mid \\mathrm{GCD}(a, b-a)\\)</li> <li>\\(\\mathrm{GCD}(a, b-a) \\mid \\mathrm{GCD}(a, (b-a)+a)\\)</li> </ul> <p>Let's prove that</p> \\[\\mathrm{GCD}(u, v)\\mid \\mathrm{GCD}(u, v+ku)\\] <p>Let \\(d_1\\) be the GCD on the left and \\(d_2\\) the one on the right. It's clear that \\(d_1|u\\) and \\(d_1|v\\), which implies that \\(d_1|(v+ku)\\). Now we'd like to conclude that \\(d_1|d_2\\).</p> <p>Unfortunately, we only proved that \\(d_1\\) is a common divisor of \\(u\\) and \\(v+ku\\) so far.</p> <p>Let's show that if \\(d'\\) divides both \\(a\\) and \\(b\\), then it also divides \\(d = \\mathrm{GCD}(a,b)\\).</p> <p>Proof (safely skippable)</p> <p>We can always express \\(d\\) and \\(d'\\) as</p> \\[ \\begin{cases} d' = u\\cdot \\mathrm{GCD}(d, d') \\\\ d  = v\\cdot \\mathrm{GCD}(d, d') \\\\ 1 = \\mathrm{GCD}(u, v) \\end{cases} \\] <p>where, as indicated, \\(u\\) and \\(v\\) are coprime.</p> <p>Observe that if \\(u\\) and \\(v\\) weren't coprime, their common divisor would be absorbed by \\(\\mathrm{GCD}(d, d')\\), so we'd have the same situation as above but for \\(u'=u/\\mathrm{GCD}(u,v)\\) and \\(v'=v/\\mathrm{GCD}(u,v)\\).</p> <p>Since \\(a\\) and \\(b\\) are divisible by both \\(d'\\) and \\(d\\), then \\(a' = a/\\mathrm{GCD}(d, d')\\) and \\(b' = b/\\mathrm{GCD}(d, d')\\) must still be divisible by \\(u\\) and \\(v\\). So:</p> <ul> <li>\\(u k_1 = a' = v k_2\\)</li> <li>\\(u h_1 = b' = v h_2\\)</li> </ul> <p>for some integers \\(k_1\\), \\(k_2\\), \\(h_1\\), and \\(h_2\\).</p> <p>Since \\(u\\) and \\(v\\) are coprime, then \\(u|k_2\\) and \\(u|h_2\\), i.e. \\(k_2 = u k_3\\) and \\(h_2 = u h_3\\) for some integers \\(k_3\\) and \\(h_3\\). Therefore:</p> <ul> <li>\\(a' = uv k_3\\implies a = uv \\mathrm{GCD}(d, d') k_3 = ud k_3\\)</li> <li>\\(b' = uv h_3\\implies b = uv \\mathrm{GCD}(d, d') h_3 = ud h_3\\)</li> </ul> <p>This means that \\(ud\\) is a common divisor of \\(a\\) and \\(b\\), and \\(u&gt;1\\) would imply that we found a greater divisor than \\(d\\), their GCD.</p> <p>Since \\(u = 1\\), then \\(d' = \\mathrm{GCD}(d, d')\\), i.e. \\(d'|d\\).</p> <p>End of proof!</p> <p>I seem to recall that some people include this property in the definition of the GCD itself, but I think that's slightly redundant.</p> <p>Anyway, we're done!</p> <p>Wait! How fast is this algorithm? Let's look at the reduction again:</p> \\[ \\begin{align*} ({\\color{red} 784}&amp;, {\\color{green}495}) \\\\ ({\\color{green}289}&amp;, {\\color{red} 495})&amp;\\qquad\\qquad 289 &amp;= 784 - 495 \\\\ ({\\color{red} 289}&amp;, {\\color{green}206})&amp;             206 &amp;= 495 - 289 \\\\  ({\\color{green}83}&amp;, {\\color{red} 206})&amp;             83 &amp;= 289 - 206 \\\\  ({\\color{red} 83}&amp;, {\\color{green}40}) &amp;             40 &amp;= 206 - 83\\cdot 2 \\\\   ({\\color{green}3}&amp;, {\\color{red} 40}) &amp;             3 &amp;= 83 - 40\\cdot 2 \\\\   ({\\color{red} 3}&amp;, {\\color{green}1})  &amp;             1 &amp;= 40 - 3\\cdot 13 \\end{align*} \\] <p>I can see two super Fibonacci sequences. Here's the green one:</p> Green Seq. 1 3 40 83 206 289 495 Green Mult. 0 13 2 2 1 1 1 <p>Fibonacci numbers form a sequence \\(F_0, F_1, F_2, \\ldots\\) where the recurrence relation is \\(F_i=F_{i-2}+F_{i-1}\\), for \\(i=2, 3, \\ldots\\).</p> <p>In our case, however, the recurrence relation is \\(F_i = F_{i-2}+F_{i-1}\\cdot M_{i-1}\\), where \\(F\\) is on the first row and \\(M\\) on the second row of the table.</p> <p>As an example, I highlighted 4 elements in the table: \\(206 = 40 + 83\\cdot 2\\). I call this a super Fibonacci sequence because the multipliers make it grow faster than the regular one (corresponding to all \\(M_i=1\\)).</p> <p>Fibonacci numbers grow exponentially, so the number of steps necessary to reach a number \\(n\\) is \\(\\Theta(\\log n)\\).</p> <p>Since our sequence is even faster, the number of steps is lower and all we can say for now is that the worst-case complexity of EEA is \\(O(\\log n)\\).</p> <p>Note</p> <p>Technically, \\(\\Theta\\) denotes exact growth, \\(O\\) denotes an upper bound, and \\(\\Omega\\) denotes a lower bound.</p> <p>For instance, \\(n = O(n^2)\\) is correct, though in practice people often use \\(O\\) when they really mean \\(\\Theta\\).</p> <p>Moreover, \\(n = O(n^2)\\) really means \\(n \\in O(n^2)\\), but the former notation is more common than the latter.</p> <p>Can we think of a very slow sequence? But, of course! We can build it starting from the bottom and always choosing \\(M_i=1\\):</p> \\[ \\begin{align*} \\cdots\\ &amp; \\cdots \\\\ ({\\color{red} 34}&amp;, {\\color{green}55}) \\\\ ({\\color{red} 34}&amp;, {\\color{green}21})&amp;\\qquad\\qquad 21 &amp;= 55 - 34 \\\\ ({\\color{green}13}&amp;, {\\color{red} 21})&amp;             13 &amp;= 34 - 21 \\\\ ({\\color{red} 13}&amp;, {\\color{green}8})&amp;              8 &amp;= 21 - 13 \\\\  ({\\color{green}5}&amp;, {\\color{red}8})&amp;               5 &amp;= 13 - 8 \\\\  ({\\color{red} 5}&amp;, {\\color{green}3})&amp;              3 &amp;= 8 - 5 \\\\   ({\\color{green}2}&amp;, {\\color{red} 3})&amp;             2 &amp;= 5 - 3 \\\\   ({\\color{red} 2}&amp;, {\\color{green}1})&amp;             1 &amp;= 3 - 2 \\end{align*} \\] <p>Those are basically two Fibonacci sequences! This tells us that the worst case of the EEA is indeed logarithmic or, to be precise, \\(\\Theta(\\log (\\min\\{a, b\\}))\\). Why min? Because we have two sequences: the green and the red one. Since they start and end together, the faster one dominates the other and faster growth means shorter sequence, so the time complexity is \\(\\Theta(\\min\\{\\log a, \\log b\\})\\), i.e. \\(\\Theta(\\log (\\min\\{a, b\\}))\\).</p> <p>I had no idea that the EA had such a connection with the Fibonacci numbers before writing this section. As always, check my reasoning!</p>","tags":["attack","cryptography","ECDSA","ethereum","extended euclidean algorithm","generating functions","signature malleability"]},{"location":"2024/11/26/understanding-ecdsa/#fibonacci-numbers","title":"Fibonacci numbers","text":"<p>Tip</p> <p>You can safely skip this section. You don't need it for the rest of the article, but if you want to learn about generating functions, I think this is a good opportunity.</p> <p>I want to find the base for the logarithm that appears in the time complexity of the EA and EEA algorithms.</p> <p>If we assume that Fibonacci numbers grow exponentially, i.e. \\(F_i\\sim b^i\\), then:</p> \\[ \\begin{align*} F_{i+2} &amp;= F_{i+1} + F_i \\\\ &amp;\\hspace{10pt}\\Downarrow \\\\ b^{i+2} &amp;= b^{i+1} + b^i \\end{align*} \\] <p>We divide by \\(b^i\\) and get \\(b^2-b-1 = 0\\), whose positive solution is</p> \\[b_+ = \\frac{1 + \\sqrt{5}}{2} \\approx 1.618\\] <p>That's the well-known golden ratio.</p> <p>We started from the assumption that the growth is exponential, but what's the exact expression for the \\(n\\)-th Fibonacci number, just to make sure we're correct?</p> <p>Let \\(V_0\\) be the vector of Fibonacci numbers \\(F_i\\):</p> \\(V_0:\\) \\(F_0\\) \\(F_1\\) \\(F_2\\) \\(F_3\\) \\(F_4\\) \\(F_5\\) \\(F_6\\) \\(\\ldots\\) <p>Now let's introduce the two shifted versions \\(V_1\\) and \\(V_2\\):</p> \\(V_0:\\) \\(F_0\\) \\(F_1\\) \\(F_2\\) \\(F_3\\) \\(F_4\\) \\(F_5\\) \\(F_6\\) \\(\\ldots\\) \\(V_1:\\) \\(F_0\\) \\(F_1\\) \\(F_2\\) \\(F_3\\) \\(F_4\\) \\(F_5\\) \\(\\ldots\\) \\(V_2:\\) \\(F_0\\) \\(F_1\\) \\(F_2\\) \\(F_3\\) \\(F_4\\) \\(\\ldots\\) <p>We can see that, from the third column onward, \\(V_0 = V_1 + V_2\\), because of the relation \\(F_{i+2} = F_{i+1} + F_{i}\\).</p> <p>The advantage of the vector approach is that we don't have to deal with the index \\(i\\) anymore. In a sense, we vectorized the loop and abstracted away the annoying index. The drawback is that we lost some algebraic power because, unless we introduce other operations, we don't even know how to express the fact that \\(V_1\\) is a shifted version of \\(V_0\\).</p> <p>Instead of reinventing the wheel, why don't we use a power series instead of a simple vector? I'm thinking of something like this:</p> \\[ \\begin{align*} P_0(x) &amp;= F_0 + F_1 x + F_2 x^2 + F_3 x^3 + F_4 x^4 + F_5 x^5 + \\ldots \\\\ P_1(x) &amp;= \\phantom{F_0 +} F_0 x + F_1 x^2 + F_2 x^3 + F_3 x^4 + F_4 x^5 + \\ldots \\\\ P_2(x) &amp;= \\phantom{F_0 + F_1 x +} F_0 x^2 + F_1 x^3 + F_2 x^4 + F_3 x^5 + \\ldots \\\\ \\end{align*} \\] <p>The individual elements are kept separated thanks to the different powers of \\(x\\), and we inherit lots of algebraic properties from power series!</p> <p>For instance, it's easy to see that \\(P_1(x) = x P_0(x)\\) and \\(P_2(x) = x^2 P_0(x)\\).</p> <p>Moreover, we can state algebraically what we observed before:</p> <p>We can see that, from the third column onward, \\(V_0 = V_1 + V_2\\), because of the relation \\(F_{i+2} = F_{i+1} + F_{i}\\).</p> <p>With power series, that becomes</p> \\[ P_0(x) - F_0 - F_1 x = P_1(x) - F_0 x + P_2(x) \\] <p>Note that we simply removed the unwanted terms in the first two columns:</p> \\[ \\begin{align*} P_0(x) - F_0 - F_1 x &amp;= F_2 x^2 + F_3 x^3 + F_4 x^4 + F_5 x^5 + \\ldots \\\\ P_1(x) - F_0 x &amp;= F_1 x^2 + F_2 x^3 + F_3 x^4 + F_4 x^5 + \\ldots \\\\ P_2(x) &amp;= F_0 x^2 + F_1 x^3 + F_2 x^4 + F_3 x^5 + \\ldots \\\\ \\end{align*} \\] <p>To reiterate, we expressed all the following relations at once:</p> <ul> <li>\\(F_2 = F_1 + F_0\\)</li> <li>\\(F_3 = F_2 + F_1\\)</li> <li>\\(F_4 = F_3 + F_2\\)</li> <li>\\(\\ldots\\)</li> </ul> <p>We can now express \\(P_1\\) and \\(P_2\\) in terms of \\(P_0\\). For convenience, let's write \\(P\\) instead of \\(P_0(x)\\):</p> \\[ P - F_0 - F_1 x = x P - F_0 x + x^2 P \\] <p>Now we solve for \\(P\\):</p> \\[ P = \\frac{(F_0 - F_1)x - F_0}{x^2 + x - 1} \\] <p>Since Fibonacci numbers start with \\(0\\) and \\(1\\), let's substitute \\(F_0=0\\) and \\(F_1=1\\):</p> \\[ P = \\frac{-x}{x^2 + x - 1} \\] <p>That's in implicit form. If we can put \\(P\\) in explicit form, then we can read the expression for the generic coefficient of \\(x^i\\), which, by construction, is the \\(i\\)-th Fibonacci number! Here's the form we want:</p> \\[ P(x) = \\sum_{i=0}^\\infty \\alpha_i x^i \\] <p>The coefficient \\(\\alpha_i\\) is bound to be a general expression for \\(F_i\\).</p> <p>How do we do that?</p> <p>Let's take the simplest power series we can think of and find both the explicit and implicit forms for it:</p> \\[ S(x) = 1 + x + x^2 + x^3 + x^4 + \\ldots \\] <p>We can use the same trick, i.e. the shift:</p> \\[ \\begin{align*} S(x) &amp;= 1 + x + x^2 + x^3 + x^4 + x^5 + \\ldots \\\\ xS(x) &amp;= \\phantom{1 +} x + x^2 + x^3 + x^4 + x^5 + \\ldots \\\\ S(x) - xS(x) &amp;= 1 \\end{align*} \\] <p>Maybe surprisingly:</p> \\[ \\begin{gather*} S(x) - xS(x) = 1 &amp;\\implies \\\\ (1 - x) S(x) = 1 &amp;\\implies \\\\ S(x) = \\frac{1}{1 - x} \\end{gather*} \\] <p>Written more formally, we proved that</p> \\[ \\sum_{i=0}^\\infty x^i = \\frac{1}{1-x} \\] <p>We don't care about convergence, as we only want to read the coefficients of the series. As long as what we do is algebraically correct, we should be fine. We might say that we're repurposing some algebraic machinery to do \"something else\".</p> <p>Note</p> <p>We say a series converges if it evaluates to a real number. Otherwise, we say it diverges. For instance, the following series clearly converges: $$ \\sum_{i=0}^\\infty \\left(\\frac{1}{10}\\right)^i = 1 + 0.1 + 0.01 + \\ldots = 1.1111\\ldots $$</p> <p>In the Fibonacci case, we want to find \\(\\alpha_i\\) such that</p> \\[ \\sum_{i=0}^\\infty \\alpha_i x^i = \\frac{-x}{x^2 + x - 1} \\] <p>Now that we've witnessed how the simple case works, we should have more confidence that this method might just work! It might still look like magic, though.</p> <p>How do we close the gap between the simple case and the Fibonacci case?</p> <p>First, we notice that the denominator is factorizable:</p> \\[ P = \\frac{-x}{(x - c_1)(x - c_2)} \\] <p>where</p> \\[ \\begin{align*} c_1 &amp;= \\frac{-1 + \\sqrt5}{2} \\\\ c_2 &amp;= \\frac{-1 - \\sqrt5}{2} \\end{align*} \\] <p>These are the same solutions we found for \\(b\\) at the start of this section, but multiplied by \\(-1\\).</p> <p>Now we can split the expression into two simpler ones:</p> \\[ \\frac{-x}{(x - c_1)(x - c_2)} = \\frac{A}{x - c_1} + \\frac{B}{x - c_2} \\] <p>We just need to find the appropriate \\(A\\) and \\(B\\) to get \\(-x\\) at the numerator:</p> \\[ \\begin{gather*}   \\frac{A}{x - c_1} + \\frac{B}{x - c_2} =\\\\   \\frac{A(x-c_2) + B(x-c_1)}{(x-c_1)(x-c_2)} =\\\\   \\frac{x(A+B) - c_2 A - c_1 B}{(x-c_1)(x-c_2)} \\end{gather*} \\] <p>We want \\(-x = x(A+B) - c_2 A - c_1 B\\), so we must have</p> \\[ \\begin{cases} A+B = -1 \\\\ c_2 A + c_1 B = 0 \\end{cases} \\] <p>The solutions are</p> \\[ \\left\\{ \\begin{align*} A = \\frac{-c_1}{c_1-c_2} \\\\ B = \\frac{c_2}{c_1-c_2} \\end{align*} \\right. \\] <p>Therefore:</p> \\[ (c_1-c_2) P = - \\frac{c_1}{x - c_1} + \\frac{c_2}{x - c_2} \\] <p>If we can convert each of the two parts into explicit form, then we're done, since explicit forms sum nicely: we just sum the corresponding coefficients.</p> <p>Now we divide numerator and denominator of the left part by \\(c_1\\) and of the right part by \\(c_2\\):</p> \\[ (c_1-c_2) P = - \\frac{1}{\\frac{x}{c_1} - 1} + \\frac{1}{\\frac{x}{c_2} - 1} \\] <p>We change some signs:</p> \\[ (c_1-c_2) P = \\frac{1}{1 - \\frac{x}{c_1}} - \\frac{1}{1 - \\frac{x}{c_2}} \\] <p>Success:</p> \\[ (c_1-c_2) P =   \\left(     \\sum_{i=0}^\\infty \\left(\\frac{x}{c_1}\\right)^i   \\right) - \\left(     \\sum_{i=0}^\\infty \\left(\\frac{x}{c_2}\\right)^i   \\right) \\] <p>Expanding and simplifying:</p> \\[ (c_1-c_2)P = \\sum_{i=0}^\\infty \\left(\\frac{1}{c_1^i} - \\frac{1}{c_2^i}  \\right)x^i = \\sum_{i=0}^\\infty \\frac{c_2^i-c_1^i}{c_1^i c_2^i} x^i \\] <p>We can simplify it further, since \\(c_1 c_2 = -1\\) and \\(c_1 - c_2 = \\sqrt5\\):</p> \\[ P = \\sum_{i=0}^\\infty (-1)^i \\frac{c_2^i-c_1^i}{\\sqrt5} x^i \\] <p>At last:</p> \\[ F_i = (-1)^i \\frac{c_2^i-c_1^i}{\\sqrt5} \\] <p>with</p> \\[ \\begin{align*} c_1 &amp;= \\frac{-1 + \\sqrt5}{2} \\\\ c_2 &amp;= \\frac{-1 - \\sqrt5}{2} \\end{align*} \\] <p>Let's check this with the simplest and dumbest Python code possible:</p> <pre><code>from math import sqrt\n\ns5 = sqrt(5)\nc1 = (-1 + s5) / 2\nc2 = (-1 - s5) / 2\n\ndef fib(i):\n    return (-1)**i * (c2**i - c1**i)/s5\n\n[int(fib(i)) for i in range(20)]\n</code></pre> <p>Fingers crossed:</p> <pre><code>[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181]\n</code></pre> <p>Phew...</p> <p>If we substitute \\(c_1\\) and \\(c_2\\) in the formula, we get</p> \\[ F_i = \\frac{(1+\\sqrt5)^i-(1-\\sqrt5)^i}{2^i\\sqrt5} \\] <p>We obtained the same solutions we found for \\(b\\), and we get the same asymptotic growth as well.</p> <p>Indeed, the numerator grows as \\((1+\\sqrt5)^i\\):</p> \\[ \\lim_{i\\to\\infty} \\frac{(1+\\sqrt5)^i-(1-\\sqrt5)^i}{(1+\\sqrt5)^i} =   \\lim_{i\\to\\infty} \\left(1 - \\left(\\frac{1 - \\sqrt5}{1 + \\sqrt5}\\right)^i\\right) = 1 \\] <p>So, \\(F_i \\sim \\frac{\\phi^i}{\\sqrt5} = \\Theta(\\phi^i)\\), where \\(\\phi = \\frac{1+\\sqrt5}{2}\\).</p> <p>By the way, \\(P(x) = \\sum_{i=0}^\\infty F_i x^i\\) is called a generating function.</p>","tags":["attack","cryptography","ECDSA","ethereum","extended euclidean algorithm","generating functions","signature malleability"]},{"location":"2024/11/26/understanding-ecdsa/#secp256k1","title":"secp256k1","text":"<p>Ethereum's ECDSA uses the elliptic curve secp256k1, defined as</p> \\[y^2 = x^3 + 7\\ (\\mathrm{mod}\\ p)\\] <p>where \\(p\\) is a very big prime number.</p> <p>Here's what the continuous version (i.e. without mod) of the curve looks like:</p> <p></p> <p>The continuous elliptic curve is the set of all points \\((x, y)\\) in the plane such that \\(y^2 = x^3 + 7\\). Because \\(y\\) is squared, the curve is symmetric about the X-axis, i.e. \\((x, y)\\) is on the curve if and only if \\((x, -y)\\) is.</p> <p>When we switch to mod \\(p\\), things get complicated:</p> <p></p> <p>To draw that picture I used \\(p = 97\\), a small prime. The blue line is the continuous curve, while the dots are the solutions in \\(\\mathbb{Z}_p\\times\\mathbb{Z}_p\\). Note that those solutions must always be finitely many, since they lie on a \\(p\\times p\\) grid.</p> <p>This figure only shows the upper right part (1st quadrant) of the previous one, so we can't see the symmetry of the continuous curve. Yet, the points in \\(\\mathbb{Z}_p\\times\\mathbb{Z}_p\\) show a new symmetry: they're reflected across the horizontal line \\(y = p/2\\). That makes sense:</p> <ul> <li>\\((x, y)\\) lies on the continuous curve if and only if \\((x, -y)\\) also lies on it.</li> <li>If \\(y\\in\\mathbb{Z}_p\\), then \\(-y = p-y\\).</li> <li>This means that \\((x, y)\\) lies on the mod curve if and only if \\((x, p-y)\\) also lies on it.</li> <li>\\(y = p-y\\) gives us \\(y = p/2\\). In the figure the axis of symmetry is \\(y = 97/2 = 48.5\\).</li> </ul> <p>Let's plot the negative solutions as well:</p> <p></p> <p>As we can see, the part above is identical to the part below, since adding \\(p\\) or \\(-p\\) to a coordinate doesn't change anything mod \\(p\\).</p>","tags":["attack","cryptography","ECDSA","ethereum","extended euclidean algorithm","generating functions","signature malleability"]},{"location":"2024/11/26/understanding-ecdsa/#group","title":"Group","text":"<p>A group \\(G\\) is a set of elements equipped with a binary operation, \\(+\\), such that:</p> <ul> <li>For any elements \\(a, b\\in G\\), we must have \\(a+b \\in G\\).</li> <li>There's a neutral element, or identity, \\(0\\), so that \\(a+0 = 0+a = a\\) for every \\(a\\in G\\).</li> <li>For every \\(a\\in G\\), there exists an additive inverse, or opposite, of \\(a\\), denoted as \\(-a\\), such that \\(a+(-a) = (-a)+a = 0\\).<ul> <li>Note: \\(a+(-b)\\) can also be written as \\(a-b\\).</li> </ul> </li> <li>We also want associativity, i.e., for all \\(a,b,c\\in G\\), we must have \\(a + (b+c) = (a+b) + c\\). So, we can drop the parentheses and write \\(a+b+c\\).</li> </ul> <p>If for all \\(a, b\\in G\\) we have \\(a+b = b+a\\), then \\(G\\) is abelian or commutative.</p> <p>Notice that we can't have two distinct identities \\(0_1 \\neq 0_2\\), since</p> \\[0_1 = 0_1+0_2 = 0_2\\] <p>Let's break it down:</p> <ul> <li>\\(0_1+0_2\\) can be simplified in two ways:<ul> <li>Since \\(0_1\\) is an identity, then it disappears, so \\(0_1+0_2 = 0_2\\)</li> <li>Since \\(0_2\\) is an identity, then it disappears, so \\(0_1+0_2 = 0_1\\)</li> </ul> </li> </ul> <p>Therefore, the two identities must be equal.</p> <p>The same goes for the additive inverse. If \\(x\\) and \\(y\\) are opposites of \\(a\\) then:</p> \\[ \\begin{align*} a+x &amp;= 0 \\\\ a+y &amp;= 0 \\end{align*} \\] <p>That means that:</p> \\[ \\begin{align*} a+x &amp;= a+y &amp;\\implies \\\\ x+(a+x) &amp;= x+(a+y) &amp;\\implies \\\\ (x+a)+x &amp;= (x+a)+y &amp;\\implies \\\\ 0+x &amp;= 0+y &amp;\\implies \\\\ x &amp;= y \\end{align*} \\] <p>So there's only one inverse per element.</p> <p>Given a subset \\(S\\) of elements from \\(G\\), we can define the subgroup \\(G_S\\) of \\(G\\) generated by \\(S\\) as the smallest group that includes all the elements of \\(S\\). We say that \\(S\\) is a generator of \\(G_S\\).</p> <p>In this article we'll only describe in detail the case where \\(S\\) has just one element. For simplicity, we'll use the same symbol for the subgroup and its generator, so a generator \\(G\\) generates the (sub)group \\(G\\) defined as follows:</p> \\[G = \\{0, G, G+G, G+G+G, G+G+G+G, \\ldots\\}\\] <p>That's very cumbersome to read and write, so let's define</p> \\[nG = G_1 + G_2 + \\cdots + G_n,\\ \\mathrm{where}\\ G_1 = G_2 = \\cdots = G_n = G\\] <p>Now we can rewrite the definition as</p> \\[G = \\{0, G, 2G, 3G, 4G, \\ldots\\}\\] <p>or even</p> \\[G = \\{0G, 1G, 2G, 3G, 4G, \\ldots\\}\\] <p>where we define \\(0G = 0\\).</p>","tags":["attack","cryptography","ECDSA","ethereum","extended euclidean algorithm","generating functions","signature malleability"]},{"location":"2024/11/26/understanding-ecdsa/#a-group-for-the-elliptic-curve","title":"A group for the elliptic curve","text":"<p>ECDSA defines a group over the points on the curve mod \\(p\\). To do that, we first need to define an addition between points.</p> <p>Here's how it's done on the continuous version of the elliptic curve:</p> <p></p> <p>If \\(P\\) and \\(Q\\) are two points on the curve, then \\(P+Q\\) is the reflection across the X-axis of the intersection between the curve and the line passing through \\(P\\) and \\(Q\\).</p> <p>The line through \\(P\\) and \\(Q\\) always intersects the curve at a third point, except when the line is perfectly vertical. In that case, the line is said to intersect the curve at \\(0\\), called the point at infinity. The point \\(0\\) acts as the identity, but is not really part of the curve, so it needs to be handled as a special case.</p> <p>Now, observe that the line through \\(R = (x, y)\\) and \\(-R = (x, -y)\\) is vertical, so \\(R+(-R)=0\\), as suggested by the \"\\(-\\)\" sign.</p> <p>Note</p> <p>Usually, the point at infinity is denoted by \\(\\mathcal{O}\\) and the origin by \\(0 = (0, 0)\\). However, since we have no need for the origin in this context, we'll denote the point at infinity by \\(0\\), stressing the fact that it's the zero of the group.</p> <p>When \\(P = Q\\), the line through \\(P\\) and \\(Q\\) is taken to be the tangent to the curve at \\(P\\) (or, equivalently, \\(Q\\)). It makes sense:</p> <ul> <li>Just imagine fixing \\(P\\) and sliding \\(Q\\) along the curve from one side of \\(P\\) to the other.</li> <li>If we want the animation of the line during the sliding to be continuous, the line must be the tangent when \\(P = Q\\).</li> </ul> <p>After all, the animation is continuous when the slope of the line is continuous, and the slope is continuous at a point when it's equal to its limit, i.e. the derivative, at that point.</p> <p>Here's a figure with a fixed point \\(P\\) and secants through \\(P\\) and several \\(Q_i\\) points that converge to \\(P\\). I chose a color map such that the closer a \\(Q_i\\) is to \\(P\\), the bluer the secant through it becomes.</p> <p></p> <p>By the way, we still count the tangent line as intersecting the elliptic curve in three points, with two coinciding at the point of tangency.</p> <p>But how is it possible that even an \"almost vertical\" line through two points on the curve always intersects the curve at a third point? Such a line intersects the curve either at a point towards \\((+\\infty, +\\infty)\\) or \\((+\\infty, -\\infty)\\).</p> <p>For \\(x\\to+\\infty\\):</p> <ul> <li>line:<ul> <li>\\(y = mx + q \\sim mx\\)</li> </ul> </li> <li>curve:<ul> <li>\\(y^2 = x^3 + 7 \\sim x^3 \\implies\\)<ul> <li>\\(y \\sim x^{3/2}\\) (upper branch)</li> <li>\\(y \\sim -x^{3/2}\\) (lower branch)</li> </ul> </li> </ul> </li> </ul> <p>What we're saying is that when \\(x\\) becomes very big, additive terms such as \\(q\\) and \\(7\\) are dwarfed and can be ignored, so the line grows like \\(mx\\), while the curve grows like \\(x^{3/2}\\). The curve grows asymptotically faster, so, when \\(m &gt; 0\\), the upper branch of the curve will hit the line from below and cross it sooner or later. Similarly, when \\(m &lt; 0\\), the lower branch of the curve will hit the line from above and cross it.</p> <p>Here's a visual example for \\(m&gt;0\\):</p> <p></p>","tags":["attack","cryptography","ECDSA","ethereum","extended euclidean algorithm","generating functions","signature malleability"]},{"location":"2024/11/26/understanding-ecdsa/#finding-the-intersection-point","title":"Finding the intersection point","text":"<p>The algebra is easy enough. We just compute the intersection between the curve and the line. Let's start from the two points \\(P = (x_P, y_P)\\) and \\(Q = (x_Q, y_Q)\\).</p> <p>If the line is vertical, the third intersection point is \\(0\\). Otherwise, its equation has the form \\(y = mx + q\\), where</p> \\[ \\begin{align*} m &amp;= \\frac{y_Q-y_P}{x_Q-x_P} \\\\ q &amp;= y_P - m x_P \\end{align*} \\] <p>We need to solve for \\(x\\) and \\(y\\) the system</p> \\[ \\left\\{ \\begin{align*} y &amp;= mx + q \\\\ y^2 &amp;= x^3 + 7 \\end{align*} \\right. \\] <p>We substitute the first equation into the second and get</p> \\[ \\begin{gather*} (mx + q)^2 = x^3 + 7 &amp;\\iff\\\\ m^2x^2 + q^2 + 2mqx = x^3 + 7 &amp;\\iff\\\\ x^3 - m^2x^2 - 2mqx + 7 - q^2 = 0 \\end{gather*} \\] <p>Before giving in to despair, we remember that we already know two solutions, \\(x_P\\) and \\(x_Q\\), and we're looking for the third point \\(-R = (x_{-R}, y_{-R})\\). This means that the LHS of the equation in \\(x\\) must be factorizable as</p> \\[(x - x_P)(x - x_Q)(x - x_{-R}) = 0\\] <p>Let's expand it to get</p> \\[x^3 + x^2(-x_P-x_Q-x_{-R}) + \\ldots = 0\\] <p>The second term is all we need: for the two LHS to be equal, we must have</p> \\[ \\begin{align*} -m^2 &amp;= -x_P-x_Q-x_{-R} \\iff\\\\ x_{-R} &amp;= m^2 - x_P - x_Q \\end{align*} \\] <p>The \\(y\\) coordinate is simply \\(y_{-R} = m x_{-R} + q\\).</p> <p>Therefore, the sum of the two points can be computed as</p> \\[ \\left\\{     \\begin{align*}         m &amp;= (y_Q-y_P)/(x_Q-x_P) \\\\         x_R &amp;= m^2 - x_P - x_Q \\\\         y_R &amp;= m (x_P - x_R) - y_P     \\end{align*} \\right. \\] <p>As we can see, finding the sum of two points requires subtractions, multiplications, and one division to compute \\(m\\). To sum two points on the curve mod \\(p\\), we just need to do the calculations mod \\(p\\). We know how to \"divide\" mod \\(p\\), so we're good.</p> <p>Let's briefly go through the case with \\(P=Q=(x,y)\\). Recall that we need to consider the tangent to the curve at \\((x,y)\\). Note that for \\(y=0\\) the tangent is perfectly vertical, so the result is \\(0\\) (look at the figure). For \\(y\\neq 0\\), we need to compute the derivative.</p> <p>We start from the equation</p> \\[y^2 = x^3 + 7\\] <p>and derive both sides with respect to \\(x\\):</p> \\[2y \\frac{dy}{dx} = 3x^2\\] <p>We solve for the derivative:</p> \\[\\frac{dy}{dx} = \\frac{3x^2}{2y}\\] <p>That's our \\(m\\).</p> <p>A complete implementation will also handle the (trivial) edge cases with \\(P=0\\) or \\(Q=0\\), of course.</p>","tags":["attack","cryptography","ECDSA","ethereum","extended euclidean algorithm","generating functions","signature malleability"]},{"location":"2024/11/26/understanding-ecdsa/#why-reflect-the-intersection-point","title":"Why reflect the intersection point","text":"<p>Having to reflect the intersection point might seem a little arbitrary at first, but if we think about it, not reflecting it is problematic. Indeed, since the three points lie on the same line, without reflection all the following equations would hold:</p> <ul> <li>\\(P + Q = R\\)</li> <li>\\(P + R = Q\\)</li> <li>\\(Q + R = P\\)</li> </ul> <p>By summing the first two equations, we'd get \\(2P+Q+R=R+Q\\), i.e. \\(P=0\\). Analogously, by summing the last two equations, we'd get \\(R=0\\). Since \\(P=Q=R=0\\), that rule would only work for \\(0\\).</p> <p>The correct rule will look less asymmetric if we think of it as \\(P+Q+R=0\\), which gives</p> <ul> <li>\\(P+Q=-R\\)</li> <li>\\(P+R=-Q\\)</li> <li>\\(Q+R=-P\\)</li> </ul> <p>But what about this point at infinity? Where does it come from? All I know is that it has to do with the so-called projective space.</p> <p>I got somewhat acquainted with that space when I was doing 3D graphics. In 3D, we may add a 4th coordinate, so that \\((x, y, z)\\) is represented by \\((wx, wy, wz, w)\\) and some computations become more regular (i.e. with fewer exceptions). At the end, we divide by \\(w\\) to go back to the usual coordinates.</p> <p>There's also the 2D case when we project a 3D scene onto a 2D screen: \\(\\pi(x, y, z) = (x/z, y/z)\\), where I used \\(\\pi\\) for projection. This has to do with how we perceive the world, so that the farther an object is from us, the smaller it looks (assuming, from our POV, that \\(z\\) is the distance of the object from us).</p>","tags":["attack","cryptography","ECDSA","ethereum","extended euclidean algorithm","generating functions","signature malleability"]},{"location":"2024/11/26/understanding-ecdsa/#projective-space","title":"Projective space","text":"<p>Let's say we have some 3D space. We make it projective by imposing that, in general, \\((x, y, z) \\sim (\\lambda x, \\lambda y, \\lambda z)\\) for all \\(\\lambda\\neq 0\\), and \\((x, y, z)\\neq(0, 0, 0)\\), where \\(\\sim\\) means equivalent. In words, all non-zero scalings of a non-zero point are equivalent. Those are all the points, origin excluded, on the same line through the origin.</p> <p>The classes partition the punctured (i.e. without the origin) 3D space. The origin, if included, would be in its own singleton class \\(\\{0\\}\\) anyway. If we instead allowed \\(\\lambda = 0\\), then two points \\(x\\) and \\(y\\) on different lines through the origin would violate the equivalence relation: \\(x\\sim 0\\) and \\(y\\sim 0\\), but \\(x\\nsim y\\).</p> <p>Indeed, an equivalence relation must follow three rules:</p> <ul> <li>reflexivity: \\(x\\sim x\\)</li> <li>symmetry: \\(x\\sim y\\iff y\\sim x\\)</li> <li>transitivity: \\(x\\sim y \\wedge y\\sim z\\implies x\\sim z\\)</li> </ul> <p>where \"\\(\\wedge\\)\" means \"and\".</p> <p>To remember the rules, we can just think of equality, which is also an equivalence relation:</p> <ul> <li>\\(a=a\\)</li> <li>\\(a=b\\iff b=a\\)</li> <li>\\(a=b\\wedge b=c\\implies a=c\\)</li> </ul> <p>So, if \\(x\\sim 0\\) and \\(0\\sim y\\), then we must have \\(x\\sim y\\). If \\(0\\) is equivalent to elements that belong to different classes, then it breaks transitivity.</p> <p>Since the origin doesn't belong to the projective space, any generic point \\((x, y, z)\\) in it is to be considered non-zero.</p> <p>Back to our elliptic equation. On the 2D plane, the equation is \\(y^2 = x^3 + 7\\), but that won't work in the projective space. Since \\((x, y, z)\\sim (\\lambda x, \\lambda y, \\lambda z)\\), with \\(\\lambda\\neq 0\\), we'd like for \\((\\lambda x, \\lambda y, \\lambda z)\\) to be on the curve whenever \\((x, y, z)\\) is.</p> <p>Let's write the equation in the projective space as</p> \\[Y^2 = X^3 + 7\\] <p>and do the substitution \\((X, Y, Z) = (\\lambda x, \\lambda y, \\lambda z)\\):</p> \\[\\lambda^2 y^2 = \\lambda^3 x^3 + 7\\] <p>We want that to hold whenever \\((x, y, z)\\) is a solution, i.e. whenever \\(y^2 = x^3 + 7\\). For that to happen, the equation must factorize as</p> \\[f(\\lambda)(y^2 - x^3 - 7) = 0\\] <p>so that when the second factor is \\(0\\), the equation holds regardless of the factor with \\(\\lambda\\).</p> <p>We still have a \\(Z\\) to add, so why not use it to balance the degree of the terms? That is:</p> \\[Y^2 Z = X^3 + 7 Z^3\\] <p>Now the substitution gives</p> \\[ \\begin{gather*} \\lambda^3 y^2 z = \\lambda^3 x^3 + 7 \\lambda^3 z^3 &amp;\\iff \\\\ \\lambda^3 (y^2 z - x^3 - 7 z^3) = 0 \\end{gather*} \\] <p>We did it, but what about that annoying extra \\(z\\)? If we want to recover the original equation, we need to set \\(z=1\\), i.e. we need to restrict ourselves to \\((x, y, 1)\\).</p> <p>That's perfectly fine, though: the original curve lies on the \\(z=1\\) plane, while on each \\(z=\\lambda\\) plane, with \\(\\lambda\\neq 0\\), lies a \\(\\lambda\\)-scaled version of the original curve:</p> <p></p> <p>With this setup, we can say that either all the elements of an equivalence class (a punctured line through the origin) are on the curve or none of them are.</p> <p>There's actually an easier way to get the equation in \\(x\\), \\(y\\), and \\(z\\) coordinates. The original 2D curve is embedded in the 3D space by adding a \\(z = 1\\) coordinate, i.e.</p> \\[(x, y)\\mapsto (x, y, 1) \\sim (\\lambda x, \\lambda y, \\lambda) = (X, Y, Z)\\] <p>Starting from a generic point \\((X, Y, Z)\\) with \\(Z\\neq 0\\), we can go back to the 2D case by just dividing by \\(Z\\) and dropping the third coordinate, i.e.</p> \\[(x, y) = (X/Z, Y/Z)\\] <p>Now, let's substitute \\(x = X/Z\\) and \\(y = Y/Z\\) into the starting equation and get rid of the denominators:</p> \\[ \\begin{align*} y^2 &amp;= x^3 + 7 \\\\ (Y/Z)^2 &amp;= (X/Z)^3 + 7 \\\\ \\frac{Y^2}{Z^2} &amp;= \\frac{X^3}{Z^3} + 7 \\\\ Y^2 Z &amp;= X^3 + 7Z^3 \\end{align*} \\] <p>One can also apply other projections. For instance, \\(x = X/Z^2\\) and \\(y = Y/Z^3\\) lead to</p> \\[ \\begin{align*} y^2 &amp;= x^3 + 7 \\\\ (Y/Z^3)^2 &amp;= (X/Z^2)^3 + 7 \\\\ \\frac{Y^2}{Z^6} &amp;= \\frac{X^3}{Z^6} + 7 \\\\ Y^2 &amp;= X^3 + 7Z^6 \\end{align*} \\] <p>This is actually nicer and used to greatly speed up computations. It's called Jacobian projection.</p> <p>We still haven't solved the mystery of the point at infinity. That was the main reason why we decided to explore projective spaces.</p>","tags":["attack","cryptography","ECDSA","ethereum","extended euclidean algorithm","generating functions","signature malleability"]},{"location":"2024/11/26/understanding-ecdsa/#point-at-infinity","title":"Point at infinity","text":"<p>We know that a vertical line intersects the planar elliptic curve either at no points at all or at the points \\(P\\), \\(-P\\), and \\(0\\) for some point \\(P\\), where \\(0\\) is the so-called point at infinity. Let's try to make sense of it.</p> <p>On the plane, a vertical line has equation \\(x = k\\), but in our projective space that's the equation of a plane. Like with the elliptic curve, we want to upgrade the equation so that if \\((x, y, z)\\) is on the line, then so is \\((\\lambda x, \\lambda y, \\lambda z)\\). We use the same substitution as before:</p> \\[ \\begin{align*} x &amp;= k \\\\ \\frac{X}{Z} &amp;= k \\\\ X &amp;= kZ \\end{align*} \\] <p>So the equation of the vertical plane becomes \\(X = kZ\\), which represents a family of \\(Z\\)-scaled vertical lines. The equation \\(X = kZ\\) makes sense since, as \\(Z\\) gets closer to \\(0\\), the line must also get closer to the origin because everything, curve included, gets scaled down.</p> <p>Let's find the intersections between the curve and the line by solving</p> \\[ \\begin{cases} Y^2 Z = X^3 + 7Z^3\\\\ X = kZ \\end{cases} \\] <p>We substitute the second equation into the first:</p> \\[Y^2 Z = k^3 Z^3 + 7Z^3\\] <p>That can be rewritten as</p> \\[Z (Z^2 (k^3 + 7) - Y^2) = 0\\] <p>For \\(Z\\neq 0\\), we can divide by \\(Z\\), so we're left with</p> \\[Z^2 (k^3 + 7) - Y^2 = 0\\] <p>which gives two solutions for each \\(Z\\neq 0\\) because of that \\(Y^2\\). Those two solutions correspond to two points \\(P\\) and \\(-P\\).</p> <p>For \\(Z = 0\\), we get \\(X = 0\\) from the second equation, i.e. the solutions are \\((0, \\lambda, 0)\\) for \\(\\lambda\\neq 0\\), which is the Y-axis without the origin. We can take \\((0, 1, 0)\\) as the representative of that class, which is exactly the point at infinity. As we can see, it doesn't live in any plane with the curve, so it doesn't exist in our original 2D space, but we already knew that.</p> <p>This reminded me that we never designated representatives for the equivalence classes. Let's see:</p> <ul> <li>Each class \\(C\\) is a punctured line through the origin.</li> <li>If \\(C\\) intersects the plane \\(Z = 1\\) at some point \\(P = (X, Y, 1)\\):<ul> <li>\\(\\mathrm{repr}(C) = P\\)</li> </ul> </li> <li>Else:<ul> <li>\\(C\\) must lie on the plane \\(Z = 0.\\)</li> <li>If \\(C\\) intersects the line \\(\\{Y=1; Z=0\\}\\) at some point \\(P = (X, 1, 0)\\):<ul> <li>\\(\\mathrm{repr}(C) = P\\)</li> </ul> </li> <li>Else:<ul> <li>\\(C\\) lies on the X-axis, i.e. \\(\\{Y = Z = 0\\}\\).</li> <li>\\(C\\) has the form \\((X, 0, 0)\\).</li> <li>\\(\\mathrm{repr}(C) = (1, 0, 0)\\)</li> </ul> </li> </ul> </li> </ul> <p>So, we have three groups of representatives:</p> <ul> <li>\\((X, Y, 1)\\): on the curve if and only if \\(Y^2 = X^3 + 7\\).</li> <li>\\((X, 1, 0)\\): on the curve if and only if \\(X = 0\\), which gives the point at infinity \\((0, 1, 0)\\).</li> <li>\\((1, 0, 0)\\): not on the curve.</li> </ul>","tags":["attack","cryptography","ECDSA","ethereum","extended euclidean algorithm","generating functions","signature malleability"]},{"location":"2024/11/26/understanding-ecdsa/#addition-in-projective-space","title":"Addition in projective space","text":"<p>Tip</p> <p>You can safely skip this section!</p> <p>Computing \\(m\\), the slope of the line through the points \\((x_1, y_1)\\) and \\((x_2, y_2)\\), requires a division, which, mod \\(p\\), is a relatively expensive operation (compared to simple additions and multiplications).</p> <p>Let's recall how to compute the point \\((x_3, y_3) = (x_1, y_1) + (x_2, y_2)\\), assuming \\(x_1\\neq x_2\\):</p> \\[ \\begin{align*} m &amp;= (y_2-y_1)/(x_2-x_1) \\\\ x_3 &amp;= m^2 - x_1 - x_2 \\\\ y_3 &amp;= m (x_1 - x_3) - y_1 \\end{align*} \\] <p>To go from the plane to the 3D projective space, we proceed as we did before with the elliptic curve and the line equations, i.e. we make the substitution \\((x,y) = (X/Z, Y/Z)\\).</p> <p>Let's start with \\(m\\):</p> \\[ \\begin{align*} m &amp;= \\frac{y_2-y_1}{x_2-x_1} \\\\   &amp;= \\frac{Y_2/Z_2 - Y_1/Z_1}{X_2/Z_2 - X_1/Z_1} \\\\   &amp;= \\frac{Y_2/Z_2 - Y_1/Z_1}{X_2/Z_2 - X_1/Z_1} \\cdot \\frac{Z_1 Z_2}{Z_1 Z_2} \\\\   &amp;= \\frac{Y_2 Z_1 - Y_1 Z_2}{X_2 Z_1 - X_1 Z_2} \\end{align*} \\] <p>We define</p> \\[ \\begin{align*} A &amp;= Y_1 Z_2 \\\\ B &amp;= Y_2 Z_1 - A \\\\ C &amp;= X_1 Z_2 \\\\ D &amp;= X_2 Z_1 - C \\end{align*} \\] <p>Therefore:</p> \\[ m = \\frac{Y_2 Z_1 - Y_1 Z_2}{X_2 Z_1 - X_1 Z_2} = \\frac{B}{D} \\] <p>Now we deal with \\(x_3\\):</p> \\[ \\begin{align*} x_3 &amp;= m^2 - x_1 - x_2 \\\\ \\frac{X_3}{Z_3} &amp;= \\frac{B^2}{D^2} - \\frac{X_1}{Z_1} - \\frac{X _2}{Z_2} \\\\ X_3 &amp;= Z_3 \\frac{B^2 Z_1 Z_2 - D^2 (X_1 Z_2 + X_2 Z_1)}{D^2 Z_1 Z_2} \\\\ &amp;= Z_3 \\frac{B^2 Z_1 Z_2 - D^2 (D + 2C)}{D^2 Z_1 Z_2} \\end{align*} \\] <p>It's \\(y_3\\)'s turn:</p> \\[ \\begin{align*} y_3 &amp;= m (x_1 - x_3) - y_1 \\\\ \\frac{Y_3}{Z_3} &amp;= \\frac{B}{D} \\left(\\frac{X_1}{Z_1} - \\frac{X_3}{Z_3}\\right) - \\frac{Y_1}{Z_1} \\\\ Y_3 &amp;= Z_3 \\frac{B(X_1 Z_3 - X_3 Z_1) - Y_1 D Z_3}{D Z_1 Z_3} \\\\ &amp;= \\frac{B(X_1 Z_3 - X_3 Z_1) - Y_1 D Z_3}{D Z_1} \\\\ &amp;= \\frac{B\\left(X_1 Z_3 - \\left(     Z_3 \\frac{B^2 Z_1 Z_2 - D^2 (D + 2C)}{D^2 Z_1 Z_2} \\right) Z_1\\right) - Y_1 D Z_3}{D Z_1} \\\\ &amp;= Z_3\\frac{B\\left(X_1 - \\frac{B^2 Z_1 Z_2 - D^2 (D + 2C)}{D^2 Z_2}\\right) - Y_1 D}{D Z_1} \\\\ &amp;= Z_3\\frac{B\\left(X_1 - \\frac{B^2 Z_1 Z_2 - D^2 (D + 2C)}{D^2 Z_2}\\right) - Y_1 D}{D Z_1}\\cdot \\frac{D^2 Z_2}{D^2 Z_2} \\\\ &amp;= Z_3\\frac{B(X_1 Z_2 D^2 - B^2 Z_1 Z_2 + D^2 (D + 2C)) - Y_1 D^3 Z_2}{D^3 Z_1 Z_2} \\\\ &amp;= Z_3\\frac{B(D^2 (D + 3C) - B^2 Z_1 Z_2) - Y_1 D^3 Z_2}{D^3 Z_1 Z_2} \\\\ \\end{align*} \\] <p>We substituted \\(X_3\\) into \\(Y_3\\), so we could factor out \\(Z_3\\), since \\(X_3 = Z_3 (\\ldots)\\).</p> <p>We end up with</p> \\[ \\begin{align*} X_3 &amp;= Z_3\\frac{B^2 Z_1 Z_2 - D^2 (D + 2C)}{D^2 Z_1 Z_2} \\\\ Y_3 &amp;= Z_3\\frac{B(D^2 (D + 3C) - B^2 Z_1 Z_2) - Y_1 D^3 Z_2}{D^3 Z_1 Z_2} \\end{align*} \\] <p>and by choosing \\(Z_3 = D^3 Z_1 Z_2\\), we get rid of the denominators:</p> \\[ \\begin{align*} X_3 &amp;= D(B^2 Z_1 Z_2 - D^2 (D + 2C)) \\\\ Y_3 &amp;= B(D^2 (D + 3C) - B^2 Z_1 Z_2) - Y_1 D^3 Z_2 \\\\ Z_3 &amp;= D^3 Z_1 Z_2 \\end{align*} \\] <p>We can clean that up further by defining</p> \\[ \\begin{align*} E &amp;= B^2 Z_1 Z_2 - D^2 (D + 2C) \\\\ F &amp;= D^3 Z_2 \\end{align*} \\] <p>which results in</p> \\[ \\begin{align*} X_3 &amp;= DE \\\\ Y_3 &amp;= B(D^2 C - E) - Y_1 F \\\\ Z_3 &amp;= Z_1 F \\end{align*} \\] <p>Note that further micro-optimizations are possible. For instance, we shouldn't compute \\(D^2\\) and \\(D^3\\) separately.</p> <p>I hope my calculations are correct, since this is my first time doing them. Either way, I'm satisfied with the result from a pedagogical point of view. I hope you are as well. As we can see, the common denominator was put in \\(Z_3\\) to avoid intermediate divisions. Now we can add many points together without any division and only do one single division when we want to go back to our 2D plane:</p> \\[ \\begin{align*} Z_{\\text{inv}} &amp;= Z^{-1} \\\\ (x, y) &amp;= (XZ_{\\text{inv}}, YZ_{\\text{inv}}) \\end{align*} \\] <p>That's one slow (at least in \\(\\mathbb{Z}_p\\)) division and 2 fast multiplications.</p> <p>Note that the \\(P=Q\\) case is handled similarly. Moreover, the same approach will also work for the Jacobian projection, i.e. for \\((x, y) = (X/Z^2, Y/Z^3)\\).</p> <p>This is almost a philosophical observation. When we substitute \\(x\\) with \\(X/Z\\), we're not promoting \\(x\\) to a fraction, but we're reexpressing it as a fraction, since they're assumed to be equal.</p> <p>For example, if \\(x\\) is a simple integer in \\(\\mathbb{Z}\\) (without mod) and we replace it with \\(X/Z\\) where \\(X\\) and \\(Z\\) are also in \\(\\mathbb{Z}\\), then we're ranking up from integers to rational numbers, which is a promotion. Indeed, unless \\(X\\) is divisible by \\(Z\\) or we're willing to lose some information, we won't be able to go back to \\(x\\) when the time comes.</p> <p>In the ECDSA case, though, \\(x\\) is in \\(\\mathbb{Z}_p\\), with \\(p\\) prime, so \\(X/Z\\) is also in \\(\\mathbb{Z}_p\\): we're not promoting \\(x\\) to something more, but just reexpressing it.</p> <p>Let's say we have a huge matrix that can be factorized into two small matrices because it's low-rank (i.e. many of its rows or columns are linear combinations of a selected few). Instead of carrying around the huge matrix during the computations, we may want to keep it in factorized form, \\((L, R)\\), and then update the factorized form itself:</p> \\[(L', R') = (f(L, R), g(L, R))\\] <p>One way to find \\(f\\) and \\(g\\) is to do the substitution \\(M = LR\\) into whatever expression we want to evaluate involving \\(M\\), and put the result back into factorized form. Note that if we end up with \\(L=I\\) or \\(R=I\\) (where \\(I\\) is the identity matrix), then the factorization is useless for our purposes.</p>","tags":["attack","cryptography","ECDSA","ethereum","extended euclidean algorithm","generating functions","signature malleability"]},{"location":"2024/11/26/understanding-ecdsa/#back-to-the-group","title":"Back to the group","text":"<p>ECDSA uses the addition operation we defined above to generate a group from a predetermined generator \\(G\\). All the considered points are on the curve mod \\(p\\), meaning that their coordinates are in \\(\\mathbb{Z}_p\\). Here's the group:</p> \\[G = \\{0, G, 2G, 3G, \\ldots, (N-1)G\\}\\] <p>Notice that \\(G\\) has only a finite number of elements, which is to be expected since the points lie on a \\(p\\times p\\) grid, which contains \\(p^2\\) distinct points at most.</p> <p>We start from \\(0\\) and keep adding \\(G\\) until we loop, i.e. we get a point that we've already seen. Let's assume this is our current list:</p> \\[0, G, 2G, 3G, \\ldots, kG, \\ldots, hG\\] <p>We assume we've just looped, so the first \\(h\\) elements are all distinct, and \\(hG = kG\\), with \\(k &lt; h\\).</p> <p>We must have \\(0 = hG-kG = (h-k)G\\). The only elements in the list that can be 0 are the first one and the last one. Since \\(h-k&gt;0\\), \\((h-k)G\\) must be the last element, so \\(h-k=h\\), which gives \\(k=0\\). This means that when we loop we restart from \\(0\\).</p> <p>So we end up with the following group:</p> \\[G = \\{0, G, 2G, 3G, \\ldots, (N-1)G\\}\\] <p>\\(G\\) has order \\(N\\), i.e. it has \\(N\\) elements. This looping should remind you of \\(\\mathbb{Z}_N\\):</p> \\[\\mathbb{Z}_N = \\{0, 1, 2, 3, \\ldots, N-1\\}\\] <p>Indeed, \\(\\mathbb{Z}_N\\) is also a (commutative) group:</p> <ul> <li>group operation: \\(+\\)</li> <li>identity: \\(0\\)</li> <li>inverse of \\(x\\): \\(-x\\)<ul> <li>so that \\(x + (-x) = (-x) + x = 0\\)</li> </ul> </li> </ul> <p>Moreover, it's generated by \\(1\\):</p> \\[\\mathbb{Z}_N = \\{0, 1, 1+1, 1+1+1, \\ldots, (N-1)1\\}\\] <p>If we couldn't inspect the single elements, and we just used the group laws, we'd actually be unable to tell \\(G\\) and \\(\\mathbb{Z}_N\\) apart.</p> <p>For instance, let's say we're given, as programmers, an opaque type <code>Element</code> together with an identity <code>zero</code> and an operation <code>add</code>. Would we be able to tell whether we're working with \\(G\\) or \\(\\mathbb{Z}_N\\) without looking inside <code>Element</code> or at the implementation? No, we wouldn't. By defining a common API, we abstracted away the differences.</p> <p>So, we've got ourselves an isomorphism between groups:</p> \\[aG + bG = (a+b)G\\] <p>More formally, let's define \\(f: a\\mapsto aG\\), which is a bijection, i.e. a 1-1 mapping between all the elements of \\(\\mathbb{Z}_N\\) and all the elements of \\(G\\). This means that we can invert \\(f\\) and use \\(f^{-1}\\) to go the other direction (however computationally expensive it is to do).</p> <p>Then the equation above can be rewritten as</p> \\[f(a) +_G f(b) = f(a+_{\\mathbb{Z}_N}b)\\] <p>That means that we can either</p> <ul> <li>transform the addends into \\(G\\)'s elements and then add them up using \\(G\\)'s addition operation, or</li> <li>sum the addends using \\(\\mathbb{Z}_N\\)'s addition operation and then transform the result into the corresponding element in \\(G\\).</li> </ul> <p>The final result will be the same.</p> <p>Another way of saying this is that we can move back and forth between \\(G\\) and \\(\\mathbb{Z}_N\\) without losing information.</p> <p>For example, for \\(N = 7\\):</p> <ul> <li>\\(3G + 5G = 8G = 7G + G = 0 + G = G\\)<ul> <li>because \\(7G = 0\\)</li> </ul> </li> <li>\\((3 + 5)G = (8)G = (1)G = G\\)<ul> <li>because \\(8\\ \\mathrm{mod}\\ 7 = 1\\)</li> </ul> </li> </ul> <p>In the first case the looping comes from \\(G\\), while in the second case it comes from \\(\\mathbb{Z}_7\\). In the second case we only worked inside the parentheses, i.e. with the numbers in \\(\\mathbb{Z}_7\\): we didn't touch \\(G\\) at all.</p> <p>The idea is to work with numbers in \\(\\mathbb{Z}_N\\), which are easier to work with, and then transform them into points by multiplying them by \\(G\\). While it's very easy to go from \\(k\\) to \\(kG\\), it's computationally infeasible to go back from \\(kG\\) to \\(k\\).</p> <p>It shouldn't surprise that ECDSA represents private keys as numbers in \\(\\mathbb{Z}_N\\), and then multiplies them by \\(G\\) to get the associated public keys. This makes recovering the private key from a public key computationally infeasible.</p>","tags":["attack","cryptography","ECDSA","ethereum","extended euclidean algorithm","generating functions","signature malleability"]},{"location":"2024/11/26/understanding-ecdsa/#signing-a-message","title":"Signing a message","text":"<p>I'll cheat a little and read my notes for the signing part of the algorithm:</p> <pre><code>* Message to sign:\n    z = 256-bit message digest\n\n* Signature generation (in F_n, i.e. mod n):\n    k = rand_unif({1, ..., n-1})        # ephemeral nonce\n    R = k * G = (R_x, R_y)\n    r = R_x mod n                       # 1st component\n    if r = 0, restart and choose a new k\n    s = (k^{-1} * (z + r * d)) mod n    # 2nd component [d = account private key]\n    if s = 0, restart and choose a new k\n    v = R_y mod 2               # AKA recid, recovery_id, or is_y_odd\n    signature = (r, s, v)\n</code></pre> <p>Let's see:</p> <ul> <li>\\(G\\) is both:<ul> <li>the group of points on the elliptic curve (with coordinates in \\(\\mathbb{Z}_p\\), with \\(p\\) prime)</li> <li>the generator of that group</li> </ul> </li> <li>\\(n\\), a prime number, is the order of \\(G\\)</li> <li>\\(z\\) is the message hash</li> <li>\\(d\\) is the private key of the account</li> <li>\\(k^{-1}\\) is the multiplicative inverse mod \\(n\\), i.e. \\(k\\cdot k^{-1} = 1\\ (\\mathrm{mod}\\ n)\\).</li> </ul> <p>Note that I wrote \\(F_n\\) or, better, \\(\\mathbb{F}_n\\) instead of \\(\\mathbb{Z}_n\\) because, when \\(n\\) is prime, the latter is actually a field. The coordinates we've been working with for all this time are in \\(\\mathbb{Z}_p\\), which is also a field, since \\(p\\) is prime. That's why I wrote \"some 3D space\" before: depending on which field we choose, we'll end up with a different 3D space.</p> <p>We basically already observed that \\(\\mathbb{Z}_n\\), with \\(n\\) prime, is a field, but we never spelled it out.</p> <p>That's actually why our math works both in the continuous case and mod \\(p\\). The theory only requires that the coordinates are elements of a field. It doesn't matter which one.</p> <p>A field \\(\\mathbb{F}\\) is a set equipped with two binary operations, addition and multiplication, such that:</p> <ul> <li>\\(\\mathbb{F}\\) is a commutative group under addition</li> <li>\\(\\mathbb{F}\\setminus\\{0\\}\\) is a commutative group under multiplication</li> <li>A distributive law holds:<ul> <li>(a+b)c = ac + bc</li> </ul> </li> </ul> <p>Note that \\(\\mathbb{F}\\setminus\\{0\\}\\) means \"\\(\\mathbb{F}\\) minus \\(\\{0\\}\\)\", i.e. \\(\\mathbb{F}\\) without the element \\(0\\).</p> <p>\\(\\mathbb{Z}_n\\setminus\\{0\\}\\), with \\(n\\) prime, is a group under multiplication because:</p> <ul> <li>Multiplication is associative: \\(a(bc) = (ab)c = abc\\).</li> <li>There's an identity: \\(1\\)</li> <li>Every (non-zero) element \\(x\\) has inverse, i.e. the famous multiplicative inverse mod \\(n\\).</li> </ul> <p>The \\(0\\) element has no multiplicative inverse since there's no \\(x\\) such that \\(0\\cdot x = 1\\). That would be against the very definition of \\(0\\) as the identity for the addition operation.</p> <p>When \\(n\\) is not prime, we lose the group under multiplication because the inverse doesn't exist for all elements. For instance, let's consider mod \\(6\\):</p> <ul> <li>\\(3\\cdot 0 = 0\\)</li> <li>\\(3\\cdot 1 = 3\\)</li> <li>\\(3\\cdot 2 = 0\\)</li> <li>\\(3\\cdot 3 = 3\\)</li> <li>\\(3\\cdot 4 = 0\\)</li> <li>\\(3\\cdot 5 = 3\\)</li> </ul> <p>Since \\(3\\) and \\(6\\) are not coprime, \\(3\\) has no inverse.</p> <p>When \\(n\\) is not a prime number, \\(\\mathbb{Z}_n\\) is just a (commutative) ring, which has a weaker structure.</p> <p>Well-known examples of fields are:</p> <ul> <li>\\(\\mathbb{Q}\\): the rational numbers</li> <li>\\(\\mathbb{R}\\): the real numbers</li> <li>\\(\\mathbb{C}\\): the complex numbers</li> </ul> <p>The integers are clearly not a field since, for instance, \\(3x = 1\\) has no integer solution, so \\(3\\) has no multiplicative inverse. So, by adding a mod \\(p\\), with \\(p\\) prime, we gain more structure, and we get ourselves a field!</p> <p>Back to the algorithm. The first two lines are pretty easy:</p> <ul> <li>We generate a random (uniformly distributed) temporary nonce \\(k\\) (a number to be used only once ever)</li> <li>We convert \\(k\\) into the associated point \\(R\\) on the curve<ul> <li>The point has coordinates \\((R_x, R_y)\\) (mod \\(p\\))</li> <li>It's computationally infeasible to go back from \\(R\\) to \\(k\\).</li> </ul> </li> <li>Note that \\(n &lt; p\\), otherwise \\(r\\) would just be \\(R_x\\).</li> </ul> <p>Since \\(d\\) is the private key, then \\(dG\\) is the public key. We'll call it \\(Q\\).</p>","tags":["attack","cryptography","ECDSA","ethereum","extended euclidean algorithm","generating functions","signature malleability"]},{"location":"2024/11/26/understanding-ecdsa/#verifying-the-signature","title":"Verifying the signature","text":"<p>Given \\(r\\), \\(s\\), \\(Q\\), and the message, we can verify the signature by:</p> <ul> <li>hashing the message to get \\(z\\)</li> <li>recovering \\(R\\)</li> <li>checking that \\(R_x\\ \\mathrm{mod \\ n} = r\\)</li> </ul> <p>We know that \\(R = kG\\) and that \\(s\\) contains \\(k\\), but in inverse form. If we invert \\(s\\) and multiply it by \\(G\\), we get</p> \\[s^{-1}G = (z+rd)^{-1}kG = (z+rd)^{-1}R\\] <p>Mhm... if we had \\(d\\), we could compute \\((z+rd)\\) and use it to cancel \\((z+rd)^{-1}\\) and get \\(R\\).</p> <p>While we don't have \\(d\\), we do have \\(Q = dG\\), which means that although we can't compute \\((z + rd)\\), we can compute \\((z + rd)G\\):</p> \\[(z + rd)G = (zG + rQ)\\] <p>If we multiply that by \\(s^{-1}\\) we get</p> \\[s^{-1}(zG + rQ) = s^{-1}G(z+rd) = (z+rd)^{-1}R(z+rd) = R\\] <p>In words, we factor out \\(G\\) from \\(zG + rQ\\) and form \\(s^{-1}G\\), which is just \\((z+rd)^{-1}R\\), as we saw at the beginning.</p> <p>We did it! Now we check that \\(r = R_x\\ \\mathrm{mod}\\ n\\).</p> <p>Here's the algorithm:</p> <ul> <li>\\(w = s^{-1}\\ \\mathrm{mod}\\ n\\)</li> <li>\\(u_1 = (z\\cdot w)\\ \\mathrm{mod}\\ n\\)</li> <li>\\(u_2 = (r\\cdot w)\\ \\mathrm{mod}\\ n\\)</li> <li>\\(R = u_1\\cdot G + u_2\\cdot Q\\)</li> <li>check that \\(r = R_x\\ \\mathrm{mod}\\ n\\)</li> </ul> <p>Observe that \\(((zw)G + (rw)Q)\\) is more efficient than \\(s^{-1}(zG + rQ)\\) because, in the former, \\(w\\) multiplies two numbers, while, in the latter, \\(s^{-1}\\) multiplies a point.</p>","tags":["attack","cryptography","ECDSA","ethereum","extended euclidean algorithm","generating functions","signature malleability"]},{"location":"2024/11/26/understanding-ecdsa/#recovering-q","title":"Recovering \\(Q\\)","text":"<p>Now the only problem is that in Ethereum the public key \\(Q\\) doesn't come with the signature. However, we can recover it from \\(r\\), \\(s\\), and \\(v\\).</p> <p>As we know, \\(Q = dG\\) and \\(s = k^{-1}(z+rd)\\), so we should try multiplying \\(s\\) by \\(G\\):</p> \\[sG = k^{-1}(z+rd)G = k^{-1}(zG + rQ)\\] <p>To solve for \\(Q\\), we need to get rid of that \\(k^{-1}\\). We can't just multiply \\(sG\\) by \\(k\\) because we don't know \\(k\\)... but wait:</p> \\[(zG + rQ) = ksG = s(kG) = sR\\] <p>Therefore:</p> \\[Q = r^{-1}(sR - zG)\\] <p>Unfortunately, we don't know \\(R\\). But can we recover it? We know \\(r = R_x\\), so we only need to recover \\(R_y\\), since \\(R = (R_x, R_y)\\). We're forgetting something, though: \\(r = R_x\\ \\mathrm{mod}\\ n\\). Recall that the coordinates of the points on the curve are in \\(\\mathbb{Z}_p\\), not \\(\\mathbb{Z}_n\\). We need to recover the original \\(R_x\\) from \\(r\\).</p> <p>We know that \\(R_x \\in \\{0, \\ldots, p-1\\}\\), and, apparently, \\(n\\) is just a little smaller than \\(p\\), which means that \\(R_x = r + jn\\) for some very small \\(j\\). We start from \\(j = 0\\) and keep trying as long as \\(r + jn &lt; p\\). We say that \\(r + jn\\) is a candidate for \\(R_x\\). Let's call the current candidate simply \\(x\\).</p> <p>Given \\(x\\), we can recover \\(y\\) by using the equation \\(y^2 = x^3 + 7\\ (\\mathrm{mod}\\ p)\\) itself and solve for \\(y\\). There are fast algorithms to do that. If there's no solution, we try the next candidate. Otherwise, we get two possible solutions: \\(y\\) and \\(-y\\). If you recall, \\(v = R_y\\ \\mathrm{mod}\\ 2\\), which tells us the solution to pick:</p> <ul> <li>if \\(y\\ \\mathrm{mod}\\ 2 = v\\), we choose \\(y\\)</li> <li>otherwise, we choose \\(-y\\)</li> </ul> <p>One might wonder why we preserve the least significant bit of \\(R_y\\) to select the correct \\(y\\). That's because if \\(y\\) is in \\(\\{0, \\ldots, p-1\\}\\), then \\(-y\\ \\mathrm{mod}\\ p = p-y\\). It's clear that \\(y + (p-y) = p\\), which is odd (being a big prime), which implies that only one of \\(y\\) and \\(-y\\) can be odd (or even) mod \\(p\\).</p> <p>Anyway, once we have \\(R = (x, y)\\), we compute \\(Q = r^{-1}(sR - zG)\\).</p> <p>Now we must check that \\(Q\\) is valid, i.e. that \\(Q\\) is on the curve. If it's not, then we try the next candidate.</p> <p>We should actually check that \\(Q\\) is in \\(G\\), but, apparently, \\(G\\) contains all the solutions of \\(y^2 = x^3 + 7\\ \\mathrm{mod}\\ p\\), so if \\(Q\\) is on the curve then it's also in \\(G\\).</p>","tags":["attack","cryptography","ECDSA","ethereum","extended euclidean algorithm","generating functions","signature malleability"]},{"location":"2024/11/26/understanding-ecdsa/#signature-malleability-attack","title":"Signature malleability attack","text":"<p>We left this for last, but after all we've been through, this is disappointingly straightforward.</p> <p>If \\((r, s, v)\\) is a signature created by signing a message \\(M\\) with a private key \\(d\\), then so is \\((r, n-s, 1-v)\\).</p> <p>That's it. The problem arises when someone blacklists \\((r, s, v)\\) (once it's been used) believing that this will prevent double spending. An attacker will use the signature \\((r, n-s, 1-v)\\) to send the same message for a second time, bypassing the blacklist.</p> <p>Instead, programs should use nonces contained directly in the messages and blacklist the nonces or the messages themselves.</p> <p>Let's see why both signatures are valid.</p> <p>Let's recall the signing algorithm:</p> <pre><code>* Message to sign:\n    z = 256-bit message digest\n\n* Signature generation (in F_n, i.e. mod n):\n    k = rand_unif({1, ..., n-1})        # ephemeral nonce\n    R = k * G = (R_x, R_y)\n    r = R_x mod n                       # 1st component\n    if r = 0, restart and choose a new k\n    s = (k^{-1} * (z + r * d)) mod n    # 2nd component [d = account private key]\n    if s = 0, restart and choose a new k\n    v = R_y mod 2               # AKA recid, recovery_id, or is_y_odd\n    signature = (r, s, v)\n</code></pre> <p>Now let's see what happens if we use \\(-k\\) instead of \\(k\\):</p> \\[ \\begin{align*} k' &amp;= -k \\\\ R' &amp;= k'G = -kG = -R = (R_x, p-R_y) \\\\ r' &amp;= R'_x\\ \\mathrm{mod}\\ n = R_x\\ \\mathrm{mod}\\ n = r \\\\ s' &amp;= (k'^{-1} (z + r'd))\\ \\mathrm{mod}\\ n \\\\    &amp;= -(k^{-1}(z + rd))\\ \\mathrm{mod}\\ n \\\\    &amp;= -(k^{-1}(z + rd)\\ \\mathrm{mod}\\ n)\\ \\mathrm{mod}\\ n \\\\    &amp;= -s\\ \\mathrm{mod}\\ n \\\\    &amp;= n-s \\\\ v' &amp;= R'_y\\ \\mathrm{mod}\\ 2 = (p-R_y)\\ \\mathrm{mod}\\ 2 = 1-v \\\\ (r', s', v') &amp;= (r, n-s, 1-v) \\\\ \\end{align*} \\] <p>That is, given the signature computed with \\(k\\), we can trivially get the one computed with \\(-k\\).</p> <p>Basically, by using \\(-k\\) instead of \\(k\\), we reflect \\(R\\) across the X-axis and flip \\(v\\) to signal that we switched the \\(y\\) coordinate.</p>","tags":["attack","cryptography","ECDSA","ethereum","extended euclidean algorithm","generating functions","signature malleability"]},{"location":"2024/11/26/understanding-ecdsa/#the-end","title":"The end","text":"<p>I hope you enjoyed the ride and deepened your understanding of ECDSA as much as I did.</p> <p>If you spot any errors, you're welcome to open an issue or start a new discussion on GitHub, though the article's nature will remain as stated in the disclaimer.</p> <p>I won't be revisiting this years later unless something truly significant comes up.</p> <p>Until next time!</p>","tags":["attack","cryptography","ECDSA","ethereum","extended euclidean algorithm","generating functions","signature malleability"]},{"location":"archive/2024/","title":"2024","text":""}]}